
3.11

The state description is only a simplified version of a world state that is a lot more complicated and has many factors that are irrelevant to the problem trying to be solved.  The search nodes are just the states following actions on the way to finding the solution to the problem that has been simplified earlier.  These distinctions make solving problems a lot easier by cutting out lots of useless information and variables that have no purpose for being considered in finding a solution.

World State
World state define a perticular real world configration exist in a system. It incorporate all information pertaining to a configration while providing the discription of the state. For example a world state discription for a truck which is travelling from Rochester to buffalo along with GPS coordinates it will inclues the personal state of driver and the music which driver is playing. All informations captured by the world state may or may not be useful while solving the associated problem.

State Discription
State Discription is a abridged version of the world state which only incudes informations which are relevent to the associated problem. Thus State discription reduce the complexites of the world state ultimately enable the designer of the problem solving AI agent to formaly define the state for AI agent so that it can perceive and store and process efficiently. 

Search Node
In a search tree, each node can have multiple childerens and each child represents the states reached by taking associated actions from the parent search node. These node represents the configration of the agent and the path from root to the node in search tree represents history of actions taken by the agents in order to achive the current configration. Root node of the search tree represents start state.




3.7


If the 2D Space containing mutiple convex obstacles has area more than the total area of convex obstacles then the cardinality of the set containing all real corrdinates which belongs to the free space is infinite. 
F(x,y)=All (x,y) -> (x,y) element of space and not an elements of the converx obstacles. Presence of free space is a neccary condition for the path but the only condition as the orientation of the obstacles also govern the possibility of the path. So the number of path can be:
0<N(P)<infinity and each path can contain infinity number of states. However the maximum number of optimum path between the source and destination is only one. The optimal path contains segments of the  straight line lines passing from the some vertices of the convex obstacles.  

In order to proof that sortest path between source and destination pass through some vertices of the convex obstacle polygones we will consider three below cases. 

Source and Destination points lyes on same or different polygone, As shown in the figure ..... In this senario we can say If point p does not ly on the AB line segment then
AP+PB > AB from pythogoras theorm.

Both source and destination points does not lyes on any polygone and there is not any straight line path between them, as shown in the figure .... Lets there exist a point p which layes on the optimal path between S and D. Here point P can be located anywhere on the free space. By relocating the point P to its one of the specific neightbour p' the total path cost will reduces as using pythogorus theorm we can say SP+PP' > SP'. The optimum value of path can only be achived by moving the point on the line segment AB as AB<AP'+P'B.







Based on our discussion in \ref{}, the state space for the given problem can be defined as the set of corrdinates representing the vertices of the conconvex polygones. Using the source and destination corrdinates along with polygone vertices we can find optimal path between the souces and distination if any path exist. 


def search_solution (goal_state, source_state):
    solution=[]
    while(goal_state//2>source_state):
        if goal_state%2>0:
            solution.insert(0,'Right')
        else:
            solution.insert(0,'left')
        goal_state=goal_state//2
		
    if goal_state==source_state:  
        return solution
    else:
        return None




def search_solution (goal_state, source_state):
	solution=[]
	while(goal_state//2>source_state):
		if goal_state%2>0:
	            solution.insert(0,'Right')
	        else:
	            solution.insert(0,'left')
	     	goal_state=goal_state//2
        
	if goal_state==source_state:  
        	return solution
    	else:
        	 return None







******************************************************************************************************************************

Definition of the state space for the problem Given the proof above,
we observe that to reach our goal (to go from a polygon vertex to
another) in a shortest path, we have to analyze just the vertices of
the obstacles, so we can safely ignore the other points (x, y) in the
free space. Abstracting the problem then, we can define the state
space of the problem as:
State space = ‚àÄ(x, y) ‚Üí (x, y) is a vertex of O (where O represents
the set of polygonal obstacles in the real plane analyzed.)
How large is this state space? : It would be the total number of vertices
of all the obstacles in the plane.
Sizess =
X
i=n
i=0
#V ertOi




The predecessor function for a node is floor(n/2). The branching factor for searching backward
from the goal is 1. The forward branching factor is 2. Since both factors are small and
similar, bidirectional search could work. Actually, we will probably be better off just doing the
backward search alone since it‚Äôs branching factor is only 1.
 
	
def (State):

	solution=[]
	while(State>0):
		if State%2>1:
			solution.insert(0,'Right')
		else:
			solution.insert(0,'left')			
		State=State/2


intial state and successor function together define state space.

world states (the actual concrete situations in the real world)
‚Äì representational states (the abstract descriptions of the real
world that are used by the agent in deliberating about what to
do).

A state space is a graph whose nodes are the set of all
states, and whose links are actions that transform one
state into another.

A search tree is a tree (a graph with no undirected loops)
in which the root node is the start state and the set of
children for each node consists of the states reachable
by taking any action.

A search node is a node in the search tree.


All these considerations are left out of our state descriptions because they are irrelevant to the problem of finding a route to Bucharest. The process of removing detail from a representation is called abstraction.

In addition to abstracting the state description, we must abstract the actions themselves.




Suppose the state space consists of all positions (x, y) in the plane.
How many spaces are there? How many paths are there to the goal?
We define our world like this: Given the world W = <
2
(the real
plane) and a finite group of convex polygonal obstacles O, our goal
is to move an agent (represented as a point) from an initial position
(xs, ys) to a final position (xg, yg), such as the path is the shortest

possible and that it is goes through the free space, defined as F =
W ‚àí O.
Our state space would be all the positions (x, y) ‚àà <2
that are in the
free space F (given that the number of obstacles is finite, it is safe
to say that the free space exists) . In the world <
2
, even if we have
just a small neighborhood of radius  > 0, the number of pairs (x, y)
inside it is infinite.
About the paths towards the goal, if the goal is reachable (in the figure
shown, it is), there are infinite paths, given that there are infinite
states. However, there is just one optimal path that is formed by a
group of vertices of the obstacles and two straight lines connecting
the initial and final positions to some vertices of the obstacles.
‚Ä¢ Explain briefly why the shortest path from one polygon vertex to any
other in the scene must consist of straight-line segments joining some
of the vertices of the polygons. Define a good state space now. How
large is this state space?
First we define the Euclidean shortest path:
The shortest path from one polygon vertex p to any other q
is expressed by: œÅ =< p, p1, p2, ..., pk, q > where each vertex
in the path is a vertex of one of the polygonal obstacles.
We can prove by contradiction that the statement above is true[1].
First, let us assume that at least one of the vertices in the shortest
path (pi) is not a vertex of the obstacles. Also, consider that each
of the vertices are not redundant (so 3 consecutives vertices are not
colinear, or the same, they form a triangle). For this, we evaluate
the 3 possible cases, shown in Fig. 5

de(pi‚àí1, pi) + de(pi
, pi+1). From this we see that if we replace pi
by p
0
i we can obtain a shorter path, which contradicts the initial
assumption of œÅ being the shortest path.
‚Äì Case 2: Both edges pi‚àí1pi and pipi+1 are on an obstacle edge or
on a tangent of a vertex. For this case, we can prove a contradiction
similar as in case 1. Lets consider 02 vertices p
0
i‚àí1
and p
0
i+1
that are the closest such that p
0
i‚àí1
pi and pip
0
i+1 are on the original
tangents. In a similar way to the case above, we can always
find a point p
0
i
such that the new distance p
0
i‚àí1
p
0
i
p
0
i+1 is shorter
than the original p
0
i‚àí1
pip
0
i+1, that means another contradiction.
‚Äì Case 3: Just one edge is on an obstacle tangent and the other is
not This is a combination of the other two cases mentioned and
is demonstrated in a similar way.
Definition of the state space for the problem Given the proof above,
we observe that to reach our goal (to go from a polygon vertex to
another) in a shortest path, we have to analyze just the vertices of
the obstacles, so we can safely ignore the other points (x, y) in the
free space. Abstracting the problem then, we can define the state
space of the problem as:
State space = ‚àÄ(x, y) ‚Üí (x, y) is a vertex of O (where O represents
the set of polygonal obstacles in the real plane analyzed.)
How large is this state space? : It would be the total number of vertices
of all the obstacles in the plane.

